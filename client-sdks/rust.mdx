---
title: "Rust SDK"
description: "Tokio-native EventDBX client with Noise-by-default transport and publish-target routing."
---

`eventdbx-client` is an async crate that speaks the EventDBX control socket (Cap'n Proto over TCP with a Noise XX handshake derived from your token). It covers list/get/select/events reads plus create/apply/patch/archive mutations.

## Install

```bash
cargo add eventdbx-client
```

## Quickstart

```rust
use eventdbx_client::{
    AppendEventRequest, ClientConfig, EventDbxClient, ListAggregatesOptions, PublishTarget,
    SetAggregateArchiveRequest,
};
use serde_json::json;

#[tokio::main]
async fn main() -> eventdbx_client::Result<()> {
    let config = ClientConfig::new("127.0.0.1", std::env::var("EVENTDBX_TOKEN")?)
        .with_tenant(std::env::var("EVENTDBX_TENANT").unwrap_or_else(|_| "default".into()))
        .with_port(6363)
        .with_noise(true); // set false (or EVENTDBX_NO_NOISE=1 on the server) to request plaintext

    let client = EventDbxClient::connect(config).await?;

    // append an event with metadata and publish targets
    let mut append = AppendEventRequest::new(
        "person",
        "p-110",
        "person_registered",
        json!({ "first_name": "Nia", "last_name": "Patel", "email": "nia@example.com" }),
    );
    append.metadata = Some(json!({ "@actor": "svc-directory" }));
    append.note = Some("seed data".into());
    append
        .publish_targets
        .push(PublishTarget::new("search-indexer").with_mode("event-only"));
    client.append_event(append).await?;

    // list aggregates with sort + pagination
    let mut list_opts = ListAggregatesOptions::default();
    list_opts.take = Some(10);
    list_opts.sort_text = Some("created_at:desc, aggregate_id:asc".into());
    let aggregates = client.list_aggregates(list_opts).await?;
    println!("aggregates: {}", aggregates.aggregates);

    // archive an aggregate with a note
    let mut archive = SetAggregateArchiveRequest::new("person", "p-110", true);
    archive.note = Some("cleanup".into());
    client.set_aggregate_archive(archive).await?;

    Ok(())
}
```

## Publish targets

Direct mutations to specific plugins and override payload mode/priority per call:

```rust
use eventdbx_client::{AppendEventRequest, PublishTarget};
use serde_json::json;

let mut request = AppendEventRequest::new("invoice", "inv-1", "invoice_created", json!({}));
request.publish_targets = vec![
    PublishTarget::new("analytics-engine").with_mode("event-only"),
    PublishTarget::new("fraud-worker").with_mode("all").with_priority("high"),
];
client.append_event(request).await?;
```

Skip `publish_targets` to fan out to all enabled plugins with their default payload mode. Publish targets are only effective when the named plugins are installed, configured, and running.

## Common verbs

```rust
use eventdbx_client::{
    AppendEventRequest, CreateAggregateRequest, EventDbxClient, ListAggregatesOptions,
    ListEventsOptions, PatchEventRequest, PublishTarget, SelectAggregateRequest,
    SetAggregateArchiveRequest,
};
use serde_json::json;

// list
let mut list = ListAggregatesOptions::default();
list.take = Some(20);
list.sort_text = Some("created_at:desc".into());
let aggregates = client.list_aggregates(list).await?;

// get
let got = client.get_aggregate("person", "p-110").await?;

// select projection
let select = client
    .select_aggregate(SelectAggregateRequest::new(
        "person",
        "p-110",
        vec!["payload.email".into(), "metadata.@actor".into()],
    ))
    .await?;

// create (first event + snapshot)
let mut create = CreateAggregateRequest::new(
    "person",
    "p-120",
    "person_registered",
    json!({ "first_name": "Ari", "email": "ari@example.com" }),
);
create.publish_targets.push(PublishTarget::new("search"));
let created = client.create_aggregate(create).await?;

// append
let mut append = AppendEventRequest::new(
    "person",
    "p-120",
    "person_email_updated",
    json!({ "email": "ari+alerts@example.com" }),
);
append.note = Some("user changed email".into());
client.append_event(append).await?;

// patch
let mut patch = PatchEventRequest::new(
    "person",
    "p-120",
    "person_registered",
    json!([{ "op": "replace", "path": "/email", "value": "ari@corp.example" }]),
);
client.patch_event(patch).await?;

// archive + restore
let mut archive = SetAggregateArchiveRequest::new("person", "p-120", true);
archive.note = Some("cleanup".into());
client.set_aggregate_archive(archive).await?;

let restore = SetAggregateArchiveRequest::new("person", "p-120", false);
client.set_aggregate_archive(restore).await?;

// list events
let events = client
    .list_events("person", "p-120", ListEventsOptions::default())
    .await?;
```

## Configuration

`ClientConfig::new(host, token)` sets sensible defaults (`port = 6363`, `tenant = "default"`, `request_timeout = 10s`, Noise enabled). Override as needed:

- `.with_tenant("tenant-123")`
- `.with_port(7000)`
- `.with_request_timeout(None)` to disable per-RPC timeouts
- `.with_connect_timeout(Duration::from_secs(2))`
- `.with_noise(false)` to request a plaintext control channel (testing only)

## Supported operations

- Reads: `list_aggregates`, `list_events`, `get_aggregate`, `select_aggregate`, `verify_aggregate`.
- Writes: `append_event`, `create_aggregate`, `patch_event`, `set_aggregate_archive` (archive/restore).
- Options: per-call token overrides, notes, metadata JSON, publish targets, pagination cursors, filter expressions, and sort directives (`"created_at:desc, aggregate_id:asc"`).
