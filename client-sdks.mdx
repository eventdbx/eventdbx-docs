---
title: "Client SDKs"
description: "Use the official EventDBX client libraries across Python, Java, PHP, NodeJS, .NET, and Go."
---

Every SDK exposes the same primitivesâ€”connect, authenticate, create aggregates, append events, and stream history. Pick the language that matches your service stack and follow the quickstart below.

<Info>
  You can always fall back to the CLI or REST API, but SDKs wrap retries,
  pagination, and typing so product engineers ship faster.
</Info>

## Typescript

```bash
npm install eventdbxjs
```

```typescript
import { createClient } from "eventdbxjs";

const client = createClient({
  ip: process.env.EVENTDBX_HOST ?? "127.0.0.1",
  port: Number(process.env.EVENTDBX_PORT) || 6363,
  token: process.env.EVENTDBX_TOKEN,
  tenantId: "default",
});

await client.connect();

await client.create("person", "p-110", "person_created", {
  payload: {
    fist_name: "Demo",
    last_name: "Demo",
    email: "jane@example.com",
  },
  metadata: { "@createdBy": "<current-id>" },
  note: "person created by <email>",
});

const history = await client.events("person", "p-110");
console.log("Event count:", history.length);

await client.disconnect();
```

Features:

- Promise-first API plus async iterables for streaming aggregate history or live tails.
- Full TypeScript declarations so payloads/metadata stay strongly typed across your app.
- Automatic reconnect + exponential-backoff retries baked into every call.

## Python

```bash
pip install eventdbx
```

```python
import json

from eventdbx import EventDBXClient

with EventDBXClient(token="<token>", tenant_id="<tenant_id>") as client:
    # Create a brand-new aggregate via the control plane
    created = client.create(
        aggregate_type="orders",
        aggregate_id="ord_123",
        event_type="created",
        payload_json=json.dumps({"total": 42.15}),
    )

    # Append follow-up events to the aggregate
    updated = client.apply(
        aggregate_type="orders",
        aggregate_id="ord_123",
        event_type="paid",
        payload_json=json.dumps({"status": "paid"}),
    )

    # List aggregates or fetch events for a specific aggregate
    aggregates = client.list(take=50)

    # Apply JSON Patch documents to historical events
    patched = client.patch(
        aggregate_type="orders",
        aggregate_id="ord_123",
        event_type="created",
        patches=[{"op": "replace", "path": "/total", "value": 45.10}],
    )

    # Archive / restore lifecycle management
    client.restore(aggregate_type="orders", aggregate_id="ord_123")
```

Features:

- Async + sync APIs.
- Typed payload helpers via `pydantic`.
- Built-in retry with exponential backoff.

## Java (Coming Soon)

```xml
<dependency>
  <groupId>com.eventdbx</groupId>
  <artifactId>eventdbx-client</artifactId>
  <version>0.5.0</version>
</dependency>
```

```java
EventDbx client = EventDbx.builder()
    .host("payments.internal")
    .port(6363)
    .token(System.getenv("EVENTDBX_TOKEN"))
    .domain("payments-prod")
    .build();

client.aggregate("invoice")
      .apply("inv-991", "invoice_paid", Map.of("amount", 4200));
```

Features:

- Reactor and CompletableFuture support for reactive stacks.
- Pluggable serializers (Jackson, Gson, your own).
- Micrometer metrics out of the box.

## PHP (Coming Soon)

```bash
composer require eventdbx/eventdbx
```

```php
$client = new EventDbx\Client([
    'host' => 'payments.internal',
    'port' => 6363,
    'token' => $_ENV['EVENTDBX_TOKEN'],
    'domain' => 'payments-prod',
]);

$client->aggregate('invoice')->apply('inv-991', 'invoice_refunded', [
    'payload' => ['amount' => 1000],
    'metadata' => ['@actor' => 'csr-22'],
]);
```

Features:

- Laravel/Symfony service providers.
- Automatic JSON encoding with depth limits.
- Middleware hooks for logging and tracing.

## .NET (Coming Soon)

```powershell
dotnet add package EventDBX.Client
```

```csharp
var client = new EventDbxClient(new EventDbxOptions {
    Host = "payments.internal",
    Port = 6363,
    Token = Environment.GetEnvironmentVariable("EVENTDBX_TOKEN"),
    Domain = "payments-prod",
});

await client.Aggregates["invoice"]
    .ApplyAsync("inv-991", "invoice_discount_applied", new {
        amount = 300,
        reason = "Loyalty"
    });
```

Features:

- `IHostedService` integration for background workers.
- Polly-based resilience policies.
- Source generators for strongly typed aggregates.

## Go (Coming Soon)

```bash
go get github.com/eventdbx/client-go
```

```go
cli := eventdbx.NewClient(eventdbx.Config{
    Host:  "payments.internal",
    Port:  6363,
    Token: os.Getenv("EVENTDBX_TOKEN"),
    Domain: "payments-prod",
})

err := cli.Aggregate("invoice").Apply(ctx, "inv-991", "invoice_settled", eventdbx.Event{
    Payload: map[string]any{"amount": 4200},
    Metadata: map[string]any{"@actor": "svc-clearing"},
})
```

Features:

- Context-aware calls for cancellation/timeouts.
- Native channels for streaming events.
- OTEL instrumentation helpers.

## Rust

```bash
cargo add eventdbx-client
```

```rust
use eventdbx_client::{
    AppendEventRequest, ClientConfig, EventDbxClient, ListAggregatesOptions,
};
use serde_json::json;
use std::env;

#[tokio::main]
async fn main() -> eventdbx_client::Result<()> {
    let host = env::var("EVENTDBX_HOST").unwrap_or_else(|_| "127.0.0.1".into());
    let token = env::var("EVENTDBX_TOKEN")?;
    let port = env::var("EVENTDBX_PORT")
        .ok()
        .and_then(|p| p.parse().ok())
        .unwrap_or(6363);
    let tenant = env::var("EVENTDBX_TENANT").unwrap_or_else(|_| "default".into());

    let config = ClientConfig::new(host, token)
        .with_port(port)
        .with_tenant(tenant);
    let client = EventDbxClient::connect(config).await?;

    let append = AppendEventRequest::new(
        "invoice",
        "inv-991",
        "invoice_paid",
        json!({ "amount": 4200 }),
    );
    client.append_event(append).await?;

    let aggregates = client
        .list_aggregates(ListAggregatesOptions::default())
        .await?;
    println!("Aggregates returned: {}", aggregates.aggregates.len());

    Ok(())
}
```

Features:

- Tokio-native async client with automatic Cap'n Proto handshake and per-call timeouts.
- Request builders (`AppendEventRequest`, `PatchEventRequest`, etc.) keep payloads strongly typed through `serde_json`.
- Optional `telemetry` feature wires into `tracing`, plus the bundled `dbxtest-cli` binary for quick smoke tests.

## Common patterns

- **Configuration**: Defer host/port/token to environment variables or service discovery.
- **Retries**: All SDKs expose hooks to adjust retry counts and logging; align them with your SLOs.
- **Testing**: Use the embedded EventDBX test harness (`dbx sandbox start`) plus SDK test utilities to stub responses.

If your language is missing, open an issue or follow the SDK template in `sdk/examples` to build your own.
