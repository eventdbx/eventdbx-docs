---
title: "Rules"
description: "Write schema rules and validation logic that keep data trustworthy."
---

Rules add business context to raw column definitions. They enforce ranges, formats, and string/object constraints inline with each field.

## Column rules via the CLI

- Required/optional: `dbx schema field <aggregate> <field> --required` or `--not-required`.
- Formats: `--format email|url|credit_card|country_code|iso_8601|wgs_84|camel_case|snake_case|kebab_case|pascal_case|upper_case_snake_case`.
- Contains / does_not_contain: `--contains foo` / `--does-not-contain bar`.
- Regex: `--regex '^[A-Z]{2}-\\d+$'` (repeatable).
- Length: `--length-min <n> --length-max <n>` for text/binary.
- Range: `--range-min <value> --range-max <value>` for numeric/date/time.
- Object properties: `--properties '{"address":{"type":"text","required":true}}'` to nest rules under an `object` field.

## Testing rules

Use fixtures before promoting to strict mode:

```bash
dbx schema validate person --event person_registered --payload @fixtures/person.json
```

Combine with CI to block changes that break validations.

## Handling failures

- In `restrict=default`, events without schemas are allowed; declared schemas validate and return clear errors when violated.
- In `restrict=strict`, every aggregate must have a schema and any rule violation rejects the write.

Use this feedback loop to educate producers about expectations while giving you the option to enforce them once confident.
